---
title: WASM 混淆
date: 2026.01.13
---

最近在定位问题时，在打包后的代码中发现一串连续的字符，在全局搜索代码后，发现是用来数据加解密的密钥。尽管前端代码是透明的，但这种直接暴露在代码中的密钥，很明显是有问题的。脱离后端的帮助，纯前端是无法真正阻止逆向或者保证密钥不被恢复，但是可以通过一些措施提高分析和提取密钥的成本。

常见的前端处理方法就是代码混淆，通过混淆代码逻辑和密钥表示形式，大幅增加逆向工程的难度和成本。很明显这是一个不错的选择，二进制格式，接近原生的性能。至于能不能编写 C/C++、C# 或 Rust 等代码，在如今看来也不是什么很大的问题，在 AI 的帮助下，可以很快的去建立一个验证环境。

```rust
#[wasm_bindgen]
pub fn aes_encrypt(data: &[u8]) -> Vec<u8> {
    const AES_KEY: [u8; 16] = [
        0x13, 0x58, 0x9b, 0xdf, 0xf4, 0x68, 0xab, 0xf0, 0x31, 0x75, 0xb9, 0xdd, 0x20, 0x64, 0xa8, 0xec
    ];
    const AES_IV: [u8; 16] = [
        0x0f, 0x1e, 0x2d, 0x3c, 0x4b, 0x5a, 0x69, 0x78, 0x87, 0x96, 0xa5, 0xb4, 0xc3, 0xd2, 0xe1, 0xf0
    ];
    aes::aes_ctr_crypt(data, &AES_KEY, &AES_IV)
}
```

截取打包后的部分 wasm 片段，可以很明显的感觉到解析这段数据的难度。

```wasm
(data (i32.const 1048576) "library/alloc/src/fmt.rs\00src\5caes.rs\00C:\5cUsers\5cadmin\5c.cargo\5cregistry\5csrc\5crsproxy.cn-e3de039b2554c837\5cwasm-bindgen-0.2.106\5csrc\5cexternref.rs\00library/alloc/src/raw*vec/mod.rs\00/rust/deps/dlmalloc-0.2.10/src/dlmalloc.rs\00library/std/src/alloc.rs\00src\5csha1.rs\00\00\00\ee\00\10\00\0b\00\00\00Q\00\00\00\14\00\00\00\ee\00\10\00\0b\00\00\00\13\00\00\00\16\00\00\00\ee\00\10\00\0b\00\00\00\14\00\00\00\15\00\00\00\ee\00\10\00\0b\00\00\00\15\00\00\00\15\00\00\00\ee\00\10\00\0b\00\00\00\16\00\00\00\14\00\00\00\01\02\04\08\10 @\80\1b6c|w{\f2ko\c50\01g+\fe\d7\abv\ca\82\c9}\faYG\f0\ad\d4\a2\af\9c\a4r\c0\b7\fd\93&6?\f7\cc4\a5\e5\f1q\d81\15\04\c7#\c3\18\96\05\9a\07\12\80\e2\eb'\b2u\09\83,\1a\1bnZ\a0R;\d6\b3)\e3/\84S\d1\00\ed \fc\b1[j\cb\be9JLX\cf\d0\ef\aa\fbCM3\85E\f9\02\7fP<\9f\a8Q\a3@\8f\92\9d8\f5\bc\b6\da!\10\ff\f3\d2\cd\0c\13\ec*\97D\17\c4\a7~=d]\19s`\81O\dc\22\*\90\88F\ee\b8\14\de^\0b\db\e02:\0aI\06$\5c\c2\d3\acb\91\95\e4y\e7\c87m\8d\d5N\a9lV\f4\eaez\ae\08\bax%.\1c\a6\b4\c6\e8\ddt\1fK\bd\8b\8ap>\b5fH\03\f6\0ea5W\b9\86\c1\1d\9e\e1\f8\98\11i\d9\8e\94\9b\1e\87\e9\ceU(\df\8c\a1\89\0d\bf\e6BhA\99-\0f\b0T\bb\16\13X\9b\df\f4h\ab\f01u\b9\dd d\a8\ecQJ\93,u\1e\b7\80\19b\ab\f4=\86\cf(q\ba\03\5c\a5\ee7\90\d9\22k\b4\fdF\8f\d8\00\00\01\00\00\00\00\00\00\00\02")
```

其实还是能隐约的找到 AES_KEY 的数据，但是这仅仅是在代码中硬编码密钥实现的，如果加上分片散布与置换，多轮混合等措施，大幅度增加了去解析 AES_KEY 的难度（当然是对人而言）。

```wasm
\13X\9b\df\f4h\ab\f01u\b9\dd d\a8\ec
```
