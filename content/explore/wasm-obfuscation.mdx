---
title: 使用 Wasm 作为加解密黑盒探索
date: 2026.01.17
---

import { AesPerformance } from "@/components/content";
import { Image } from "@/components/markdown";

最近在定位线上问题时，在打包后的代码中发现一串连续的字符，在全局搜索后，发现是用来处理数据加解密的密钥。对于开发者而言，前端代码是透明的，但是直接将密钥硬编码在代码中，很明显是不合适的。常见的做法是将这部分加解密代码做混淆，增加逆向难度。

经过混淆后的代码，可读性会大幅度下降，但是在浏览器中仍可能通过调试的方式去获取原始密钥。最根本原因是密钥硬编码在代码中，没有服务端的支持，前端能做的只是尽可能提高逆向的难度和成本。

```js
const AES_KEY = "xs10qllw4FTcQ8YUrM56triR4Ds4NrmB";
const AES_IV = "okukJvVE8fHIX1MymHg7gOo8w15Tj0He";
const get = () => {
  return [AES_KEY, AES_IV];
};
const params = get();
```

<Image
  cdn
  container={"border rounded aspect-[3/1] overflow-hidden mt-6"}
  src="/explore/wasm-obfuscation-001.webp"
  alt="Wasm 加解密黑盒"
/>

在代码执行过程中，始终会去计算出密钥用于加解密，如果可以构建一个黑盒，隐藏这一过程，就可以很好的解决这个问题。但是正如上述，前端代码是透明的，构建一个黑盒很明显是不可能的。调研近年流行技术发现，WebAssembly 可以提供一种近乎黑盒实现。将加解密的方法使用 Go/Rust 等语言重构，打包成 wasm 文件供前端调用，对于分析打包后代码或调试获取密钥有很明显的收益。

创建 WebAssembly 项目步骤就不再赘述，选定 Rust 作为重构语言。

<CodeWithTabs>

```rust !!tabs crypto_params.rs
pub const KEY: [u8; 16] = [
    0x78, 0x73, 0x31, 0x30, 0x71, 0x6c, 0x6c, 0x77, 0x34, 0x46, 0x54, 0x63, 0x51, 0x38, 0x59, 0x55,
];

pub const IV: [u8; 16] = [
    0x6f, 0x6b, 0x75, 0x6b, 0x4a, 0x76, 0x56, 0x45, 0x38, 0x66, 0x48, 0x49, 0x58, 0x31, 0x4d, 0x79,
];
```

```rust !!tabs lib.rs
#[wasm_bindgen]
pub fn encrypt(plain_text: &str) -> String {
    let ct = aes128::encrypt_cbc(
        &crypto_params::KEY,
        &crypto_params::IV,
        plain_text.as_bytes(),
    );
    key_iv_codec::hex_encode(&ct)
}

pub fn decrypt(cipher_text_hex: &str) -> Result<String, JsValue> {
    let ct =
        key_iv_codec::hex_decode(cipher_text_hex).map_err(|e| JsValue::from_str(&e.to_string()))?;
    let pt = aes128::decrypt_cbc(&crypto_params::KEY, &crypto_params::IV, &ct)
        .map_err(|e| JsValue::from_str(&e.to_string()))?;
    String::from_utf8(pt).map_err(|_| JsValue::from_str("invalid utf-8 plaintext"))
}
```

</CodeWithTabs>

重构思路如下

- 将原先的 AES_KEY/AES_IV 转换为 16 位 hex 数组，不在以明文的形式存在（此步骤在 js 中也可以实现）
- 对外输出 encrypt/decrypt 两个方法用于加解密（仅字符串接口，减少交互开销）

> 花了较多时间尝试从 wasm 中寻找 KEY/IV 的相关数据，未果。

最后是对性能开销的评估，从测试结果来看，使用 wasm 方案可能很好替代原先的 js 方案。

<AesPerformance />

> [!warn] 注意这是警告信息哈哈哈哈哈

> [!danger] hhhhhhhh 测试数据
